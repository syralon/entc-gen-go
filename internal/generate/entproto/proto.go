package entproto

import (
	"context"
	"fmt"
	"os"
	"path"

	"entgo.io/ent/entc/gen"
	"github.com/jhump/protoreflect/v2/protobuilder"
	"github.com/jhump/protoreflect/v2/protoprint"
)

type ProtoGenerator struct {
	output string

	printer *protoprint.Printer

	builder []ProtoFileBuilder
}

type ProtoOption func(*ProtoGenerator)

func WithProtoOutput(output string) ProtoOption {
	return func(g *ProtoGenerator) {
		g.output = output
	}
}

func WithProtoPrinter(printer *protoprint.Printer) ProtoOption {
	return func(g *ProtoGenerator) {
		g.printer = printer
	}
}

func WithBuilder(builders ...ProtoFileBuilder) ProtoOption {
	return func(g *ProtoGenerator) {
		g.builder = append(g.builder, builders...)
	}
}

func NewProto(opts ...ProtoOption) *ProtoGenerator {
	g := &ProtoGenerator{output: "."}
	g.apply(opts...)
	if g.printer == nil {
		g.printer = new(protoprint.Printer)
	}
	return g
}

func (g *ProtoGenerator) apply(options ...ProtoOption) {
	for _, option := range options {
		option(g)
	}
}

func (g *ProtoGenerator) AddBuilder(builder ...ProtoFileBuilder) *ProtoGenerator {
	g.builder = append(g.builder, builder...)
	return g
}

func (g *ProtoGenerator) write(idx int, fb *protobuilder.FileBuilder) (err error) {
	fb.SetSyntaxComments(LeadingComment("Code generated by chocoproto. DO NOT EDIT."))
	if fb.Path() == "" {
		fb.SetPath(fmt.Sprintf("generated_%03d.proto", idx+1))
	}
	filename := fmt.Sprintf("%s/%s", g.output, fb.Path())
	_ = os.MkdirAll(path.Dir(filename), 0700)
	file, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		return err
	}
	defer func() { err = file.Close() }()
	data, err := fb.Build()
	if err != nil {
		return err
	}
	return g.printer.PrintProtoFile(data, file)
}

func (g *ProtoGenerator) Generate(ctx context.Context, graph *gen.Graph) error {
	cc := &contextImpl{Context: ctx, deps: make(Dependencies, 0, len(g.builder))}
	for idx, b := range g.builder {
		file, err := b.Build(cc, graph)
		if err != nil {
			return err
		}
		if err = g.write(idx, file); err != nil {
			return err
		}
		cc.deps = append(cc.deps, file)
	}
	return nil
}
